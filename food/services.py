"""
STATUSES: not started, cooking, cooked, finished

BUENO HTTP POST /
```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```
RESPONSE:
```
    {
        id: string,  // generated by restaurant
        status: string
    }
```


WEBHOOK HTTP POST <SELECT>
```
    {
        id: string,
        status: string
    }
```

=================================================================

STATUS: not started, cooking, cooked, finished

MELANGE HTTP POST /api/orders
```
    order: [
        {
            dish: string
            quantity: number
        }, ...
    ]
```
```
    {
        id: string,
        status: string
    }
```

MELANGE HTTP GET /api/orders/<ID>
```
    {
        status: string
    }
```
"""

import uuid
from collections import defaultdict
from datetime import datetime, date, time
from time import sleep

from shared.cache import CacheService

import httpx
from .models import DishOrderItem, Order
from .enums import Restaurant

from celery.result import AsyncResult
from shared.cache import CacheService

class OrderInCache:
    """
    {
        "bueno"|"melange": {
            "external_id": string,
            "status": string,
            "dishes": [
                {
                    "dish": string,
                    "quantity": number,
                }, ...
            ]
        }
    }
    """
     
    def __init__(self) -> None:
        self.orders: dict[str, dict[str, str | list[dict]]] = defaultdict(dict)

    def append(self, restaurant: str, item: DishOrderItem):
        if not self.orders[restaurant]:
            self.orders[restaurant] = {
                "external_id": "",
                "status": "not_started",
                "dishes": [
                    {
                        "dish": item.dish.name,
                        "quantity": item.quantity,
                    }
                ],
            }
        else:
            self.orders[restaurant]["dishes"].append(
                {
                "dish": item.dish.name,
                "quantity": item.quantity,
                }
            )

# TODO uncomment
# @celery_app.task
def melange_order_processing(order: OrderInCache):
    while (current_status := order.orders[Restaurant.MELANGE]["status"]) != "finished":
        if current_status == "not_started":
            if not order.orders[Restaurant.MELANGE]["external_id"]:  
                payload = {"order": order.orders[Restaurant.MELANGE]["dishes"]}              
                response = httpx.post("http://localhost:8001/api/orders", json=payload)
                response.raise_for_status()
                order.orders[Restaurant.MELANGE]["external_id"] = response.json()["id"]           
            else:   
                external_order_id = order.orders[Restaurant.MELANGE]["external_id"] 
                response = httpx.get(
                    f"http://localhost:8001/api/orders/{external_order_id}"
                    )
                response.raise_for_status()

                order.orders[Restaurant.MELANGE]["status"] = response.json()["status"]

                print(f"Current status is {current_status}. Waiting 1 second")
                sleep(1)

        elif current_status == "cooking":
            external_order_id = order.orders[Restaurant.MELANGE]["external_id"] 
            response = httpx.get(
                f"http://localhost:8001/api/orders/{external_order_id}"
                )
            response.raise_for_status()

            order.orders[Restaurant.MELANGE]["status"] = response.json()["status"]

            sleep(3)
            print(f"Current status is {current_status}. Waiting 3 second")

        elif current_status == "cooked":
            print(f"CALLING DELIVERY SERVICE TO PASS THE FAOOD ORDER")

        else:
            raise ValueError(f"STATUS {current_status} is not supported!")


def bueno_order_processing(order: OrderInCache):
    print("BUENO========================")
    print(order.orders)
    print("BUENO========================")

# TODO uncomment
# @celery_app.task
def _schedule_order(order: Order):
    """Start processing restaurants orders.

    WORKFLOW:
    1. create temporary orders
    2. call restaurants APIs
    3. process orders in background
    print(f"Order started processing...{order}")"

    NOTES
    - [order: Order] includes all restaurantes
    - each provider task will run ``validate_external_orders_ready(order)``
        and the last one will update the status to ``DRIVER_LOOKUP``
    """

    order_in_cache = OrderInCache()

    for item in order.items.all():
        if (restaurant := item.dish.restaurant.name.lower()) == Restaurant.MELANGE:
            order_in_cache.append(restaurant, item)
        elif item.dish.restaurant.name.lower() == Restaurant.BUENO:
            order_in_cache.append(restaurant, item)
        else:
            raise ValueError(f"Can not create order for {item.dish.restaurant.name} restaurant")
        

        order_key = str(uuid.uuid4)
        cache = CacheService()

        cache.set(
            namespace="restaurants_order", key=order_key, instance=order_in_cache.orders
            )
        
    melange_order_processing(order_in_cache)
    bueno_order_processing(order_in_cache)

def schedule_order(order: Order)  -> AsyncResult:
    assert type(order.eta) is date

    # todo remove
    _schedule_order(order)
    return None

    # 2025-03-06  -> 2025-03-06-00:00:00 UTC
    if order.eta == datetime.today():
        print(f"The order will be started processing now")
        return schedule_order_task.apply_async(args=(order,))

    else:
        eta = datetime.combine(order.eta, time(hour=3))
        print(f"The order will be started processing {eta}")
        return schedule_order_task.apply_async(args=(order,), eta=eta)